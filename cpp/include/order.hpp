#ifndef ORDERBOOK_ORDER_HPP
#define ORDERBOOK_ORDER_HPP

#include "types.hpp"
#include <string>

namespace orderbook {

// ============================================================================
// Order Structure
// ============================================================================
//
// Represents a single order in the order book.
//
// MEMORY LAYOUT STRATEGY:
//   Fields are ordered by access frequency during matching:
//   - "Hot" fields (accessed every match check) come first
//   - "Cold" fields (accessed less frequently) come later
//   This improves cache efficiency since the CPU loads memory in cache lines.
//
// SIZE ANALYSIS:
//   id:              8 bytes
//   price:           8 bytes
//   quantity:        8 bytes
//   filled_quantity: 8 bytes
//   side:            1 byte
//   type:            1 byte
//   status:          1 byte
//   (padding):       5 bytes (compiler adds to align timestamp)
//   timestamp:       8 bytes
//   symbol:         32 bytes (std::string with SSO)
//   --------------------------
//   Total:          ~80 bytes (well under 200 byte target)
//

struct Order {
    // ========================================================================
    // Hot Fields (accessed during matching)
    // ========================================================================

    // Unique identifier for this order
    // Generated by MatchingEngine, never changes after creation
    OrderId id = INVALID_ORDER_ID;

    // Price in fixed-point format (see types.hpp)
    // For market orders, this is 0 (price is determined by the book)
    Price price = INVALID_PRICE;

    // Original quantity requested
    Quantity quantity = 0;

    // Quantity that has been filled so far
    // Invariant: filled_quantity <= quantity
    Quantity filled_quantity = 0;

    // Buy or Sell
    Side side = Side::Buy;

    // Limit or Market
    OrderType type = OrderType::Limit;

    // Current status in the order lifecycle
    OrderStatus status = OrderStatus::New;

    // ========================================================================
    // Cold Fields (accessed less frequently)
    // ========================================================================

    // When the order was created
    // Used for time priority (FIFO at same price level)
    Timestamp timestamp{};

    // Instrument identifier (e.g., "AAPL", "BTCUSDT")
    // Using std::string for flexibility; consider fixed-size char[] for ultra-low-latency
    std::string symbol;

    // ========================================================================
    // Constructors
    // ========================================================================

    // Default constructor (for containers that need it)
    Order() = default;

    // Full constructor for creating a new order
    Order(OrderId id_,
          const std::string& symbol_,
          Side side_,
          OrderType type_,
          Quantity quantity_,
          Price price_ = INVALID_PRICE)
        : id(id_)
        , price(price_)
        , quantity(quantity_)
        , filled_quantity(0)
        , side(side_)
        , type(type_)
        , status(OrderStatus::New)
        , timestamp(now())
        , symbol(symbol_)
    {}

    // ========================================================================
    // Computed Properties
    // ========================================================================

    // How much quantity is still unfilled
    // Example: quantity=100, filled_quantity=30 -> remaining=70
    Quantity remaining_quantity() const noexcept {
        return quantity - filled_quantity;
    }

    // Is this order completely filled?
    bool is_filled() const noexcept {
        return filled_quantity >= quantity;
    }

    // Is this order still active (can be matched or cancelled)?
    bool is_active() const noexcept {
        return status == OrderStatus::New ||
               status == OrderStatus::PartiallyFilled;
    }

    // Is this a buy order?
    bool is_buy() const noexcept {
        return side == Side::Buy;
    }

    // Is this a sell order?
    bool is_sell() const noexcept {
        return side == Side::Sell;
    }

    // Is this a limit order?
    bool is_limit() const noexcept {
        return type == OrderType::Limit;
    }

    // Is this a market order?
    bool is_market() const noexcept {
        return type == OrderType::Market;
    }

    // ========================================================================
    // Modifiers
    // ========================================================================

    // Fill some quantity of this order
    // Returns the actual quantity filled (may be less if order is almost full)
    // Updates status to PartiallyFilled or Filled
    Quantity fill(Quantity fill_qty) noexcept {
        // Don't overfill
        Quantity actual_fill = std::min(fill_qty, remaining_quantity());

        if (actual_fill > 0) {
            filled_quantity += actual_fill;

            // Update status
            if (is_filled()) {
                status = OrderStatus::Filled;
            } else {
                status = OrderStatus::PartiallyFilled;
            }
        }

        return actual_fill;
    }

    // Cancel this order
    // Returns true if cancellation was successful, false if order can't be cancelled
    bool cancel() noexcept {
        if (!is_active()) {
            return false;  // Already filled or cancelled
        }
        status = OrderStatus::Cancelled;
        return true;
    }
};

// ============================================================================
// Validation
// ============================================================================

// Check if an order is valid before submitting
// Returns ErrorCode::Success if valid, otherwise returns the specific error
inline ErrorCode validate_order(const Order& order) {
    // Quantity must be positive
    if (order.quantity == 0) {
        return ErrorCode::InvalidQuantity;
    }

    // Limit orders must have a valid price
    if (order.type == OrderType::Limit && order.price <= 0) {
        return ErrorCode::InvalidPrice;
    }

    // Symbol must not be empty
    if (order.symbol.empty()) {
        return ErrorCode::BookNotFound;  // No symbol means no book
    }

    return ErrorCode::Success;
}

} // namespace orderbook

#endif // ORDERBOOK_ORDER_HPP
